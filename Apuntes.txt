          1. Introducción a JavaScript

Anotación: Hay ejemplos prácticos en los videos que no realicé al ser temas que ya sé y no me hacen falta repasar. Por eso algunas carpetas pueden estar vacias.
Vincular JS con HTML: https://www.w3schools.com/tags/att_script_src.asp

    1. Sintaxis de JavaScript

Es case senstitive
Es de tipado debil/dinamico: Las variables son del tipo de dato que almacenan.
Las sentencias finalizan con ;. No es obligatorio pero es muy recomendable.
Los bloques finalizan con la lave de cierre '}'. De forma opcional se puyede añadir un ; despues de la llave.

    2. Variables y constantes scope o ámbito

Una variable es un espacio que reservamos en memoria para almacenar un dato que podrá cambiar durante la ejecución de nuestro programa.
    La palabra reservada es "let", no es recomendable usar "var".
Las variables se pueden: declarar, inicializar y modificar.
Una constante es un espacio que reservamos en memoria para almacenar un dato que no cambiará durante la ejecución de nuestro programa.
    La palabra reservada para declarar constantes es "const".
El scope o ámbito es la zona donde existe nuestra variable o constante.

    3. Declaración, inicialización y Modificación

Una variable se declara con la siguiente estructura:
    let nombre;
Una variable se inicializa con la siguiente estructura:
    numero = 5;
Se puede declarar e inicializar en la misma sentencia:
    let numero = 5;
Para modificar el valro de una variable existente:
    numero = 3;
Las constantes solo admiten la declaración e inicialización en la misma sentencia. Se modifica unicamente en su declaración.
    const PI = 3.14;

    4. Tipos de datos principales en JavaScript

Primitivos.
    Numeros -> let numero = 5;
    Strings (cadenas) -> let palabra = "hola"; let palabra = 'hola';
    Boolean -> let respuesta = true; let respuesta = false;
    Undefined.
    Null.
    Symbol.

    5. Tipos de operadores

Matématicos
    Suma/Concatenación: +.
    Resta: -.
    Multiplicación: *.
    División: /.
    Módulo: %.
Asignación
    Asignación: =.
    Suma y asignación: +=.
    Resta y asignación: -=.
    Multiplicación y asignación: *=.
    División y asignación: /=.
    Módulo y asignación: %=.
Incremento/Decremento
    Post-incremento en 1: x++.
    Pre-incremento en 1: ++x.
    Post-decremento en 1: x--.
    Pre-decremento en 1: --x.
Operadores Lógicos
    Igualdad: ==.
    Desigualdad: !=.
    Estrictamente iguales: ===. (Mismo valor y mismo tipo).
    Estrictamente desiguales: !==. (Mismo valor y mismo tipo).
    Mayor que: >.
    Menor que: <.
    Mayor o igual que: >.
    Menor o igual que: <.

    6. Strings

Método: Es todo aquello que la cadena puede hacer. Ej: Convertirse en mayúsculas.
Propiedad: Son caracteristicas que al cadena tiene por ser una cadena. Ej: Longitud.
Se cumplen utilizando la siguiente nomenclatura, al igual que con todos los objetos:
    string.método().
    string.propiedad.
Documentación de métodos y propiedades: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/String
Los template string se engloban dentro de los caracteres ``, dentro funciona de igual manera que en C#.
 
    7. Objeto Math

Documentación de Math: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Math
El objeto Math se utiliza para hacer operaciones matemáticas complejas/específicas.
Al ser un objeto también utiliza la nomenclatura del punto.

    8. Condicionales

El flujo de un programa siempre será de arriba hacia abajo.
Estructurasn de control de flujo:
    Condicionales
        Simples
        Compuestos
        Múltiples
    Bucles
        Determinados
        Indeterminados

La estructura switch tiene una sintaxis múltiple, es decir, puedo tener muchos case sin break, se van a ejecutar todos hasta encontrar un break o terminar con el programa.
Ejemplo encadenado:
    let num = 1;
    switch(num){
        case 1:
            num++;
        case 2:
            num++;
        case 3:
            num++;
        case 4:
            num++;
        case 5:
            num++;
    }
    console.log(num); -> Será 6.

Ejemplo sin encadenar
    let num = 1;
    switch(num){
        case 1:
        case 3:
        case 5:
            console.log("es impar");
            break;
        case 2:
        case 4:
            console.log("es par");
            break;
    }

    9. Operador ternario

Se utiliza cuando una condición será true o false, al igual que el if.
Su ejecución puede tener una ovarias sentencias, en este caso irán separadas por coma y entre paréntesis. Puede tener sentencias compuestas
    Condición ? (true) : (false) 
    Condición ? ((true, true) : (false, false))
    Ejemplo: (2 % 2 === 0) ? console.log("Es par") : console.log("Es impar")

    10. Arrays
 
Documentación de Array: https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array
Son estructuras que nos permiten almacenar varios datos y agruparlos.
Se pueden llenar con cualquier tipo de dato válido en JavaScript y deben ir separados por comas.
Se pueden mezclar tipos de datos en un mismo array, pero no es recomendable.
Se declaran con llaves cuadradas o corchetes.
Pueden declararse vacios o con contenido ya establecido.
Pueden añadirse o eliminarse elementos en el momento que queramos (Funcionan como listas).
Cada uno de los elementos podrá ser identificado por su índice, es decir por su posición.
Los índices empiezan a contar desde el 0.
Ejemplos de declaración:
    let numeros = [];
    let numeros = [x, z, y, b, ...];
    let numeros = new Array();

    11. Bucles
Se usan cuando queremos que un trozo de código se repita.
Existen bucles determinados e indeterminados.
Los determinados se usan cuando especificamos el número de veces que se va a repetir.
    Ej: Imprimir números del 1 al 10.
Los indeterminados los utilizamos cuando no sabemos el número de veces que se va a repetir.
    Ej: Repetir mensaje de introducir contraseña.
La estructura de un bucle es siempre la misma.
    Ej: Bucle { Código a ejecutar }.
En EMASCRIPT 6 llegaron los bucles for in y for of.
    La palabra of devolverá el valor del elemento en el array.
    La palabra in devolverá el index del elemento en el array. Podemos sacar el contenido como por ejemplo: array[variable_local]; (Como en C).



        2. Objetos, funciones y métodos
    
    1. Objetos introducción

Son estructuras de datos que representan propiedades, valores y acciones que puede realizar el objeto.
Todos los objetos tiene propiedades o atributos y comportamientoes o acciones representados por pares key:value.
Para acceder a las propiedades y acciones del objeto se utiliza la nomeclatura del punto. Otra forma es: objeto['atributo'].

    2. Funciones introducción

Son fragmentos de código que escribimos para ejectuar una tarea y no volver a escribir el mismo código más de una vez.
Nos ayuda a modularizar el código.
Las funciones deben realizar una sola tarea.
La sintaxis puede ser:
    function NOMBRE () {CODIGO A EJECUTAR};
    const NOMBRE = () => {CODIGO A EJECUTAR};
Pueden recibir parámetros.
Pueden devolver valores.
Con la palabra return devolvemos un valor.
En la funcion const al utilizar lamba existe un return implicito si hay una única instrucción, también se pueden obviar las llaves. En caso de tener mas de una linea se utiliza return.
    Ejemplo: const NOMBRE = (p1, p2) => p1 + p2; -> Return implicito

    3. Programación Orienteada a Objetos - Clases

Es un paradigma de la programación. Un paradigma es una forma de resolver un problema.
Algunos de los conceptos fundamentales son:
    Clase
    Herencia
    Objeto
    Método
    Evento
    Etc
Las clases necesitan una función constructora. Se tiene que llamar al constructor y se ejecuta cuando creemos un objeto (Desconozco si hay una clase por defecto que inicializa todo en 0 en caso de no haber constructor como en .NET).
La sintaxis es:
    class NOMBRE_DE_LA_CASE{
        constructor(PARAMETROS){
            this.ATRIBUTO
        }
    }
Los objetos pueden tener funciones asociadas a él. En ese caso se lo denomina 'Métodos'.
Para crear un objeto utilizando la clase se hace con la palabra reservada new y el nombre de la clase que queremos utilizar.
Una vez INSTANCIADO el objeto podremos acceder a sus propiedades y métodos utilizando la nomeclatura del punto o buscando su propiedad en el objeto.
Existen los getter y setters para acceder a los atributos a través de las propiedades get y set.

    4. Spread Operator

El spread operator u operador de expansión principalmente expande el contenido de un array. Se podría decir que devuelve el valor de cada index por separado.
Utiliza ... para al comienzo para indicar que es un Spread Operator.
Nos permite que una función pueda recibir una cantidad indefinida de parametros con el concepto Rest parameters: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters
Por ejemplo:
    const numbers = [12, 2, 3, 23, 43, 2, 3];
    console.log(...numbers); | OutPut => 12 2 3 23 43 2 3



        3. DOM Document Object Model    
    
            PEGAR FOTO ARBOL DOM

    1. DOM - Introducción

Documentación: https://www.w3schools.com/js/js_htmldom.asp
Se considera DOM toda la estructura HTML de un documento.
No es JavaScript, es una API (Application Programing Interface) que se utiliza a través de JavaScript que viene integrado con el navegador.
El DOM establece una jerarquia a través de nodos, constituyendo algo parecido a un arbol inverso.
Cada parte del arbol del documento es un NODO.
Hay varios tipos de nodos, los más utilizados son:
    Element node - 1 (Cualquier etiqueta HTML).
    Text node - 3 (El contenido de la etiqueta HTML).
    Comment node - 8 (Cualquier comentario en HTML).
Para vincular JavaScript con HTML utilizamos la etiqueta <script src"PATH"></script>. Se recomienda colocarla la linea anterior al cierre del body para que el script pueda acceder a todos los elementos declarados.

    2. Selección de elementos

Los elementos se guardan en una constante porque el elemento no van a cambiar.
Los pseudo-elementos no existen en el DOM, sin embargo hay formas de acceder a ellos que veremos más adelante.
document.getElementById("ID") - Acceder a un elemento a través de su id.
document/element.querySelector("SelectorCSS") - Accede al primer elemento que coincida con el selector CSS.
document/element.querySelectorAll("SelectorCSS") - Accede a todos los elementos que coincidan con el selector CSS, devuelve un nodeList.
Para los selectores CSS utilizamos el . al principio para indicar que es una clase.

    3. Atributos y clases
Atributos
    element.getAttribute("attribute"); | -> Nos devuelve el valor del atributo del elemento.
    element.setAttribute("attribute", value); -> Nos permite cambiar el valor del atributo del elemento. Tambien podemos setear el valor de un atributo que no haya sido declarado en la etiqueta en un comienzo. Ej: element.setAttribute("placeholder", "Ingrese su nombre");
Clases
    element.classList.add("class", "class", ...); | -> Añadimos una o más clases.
    element.classList.remove("class", "class", ...); | -> Remueve una o más clases.
    element.classList.toggle("class" [,force]); | -> Deshabilita o habilita una clase. Toggle devuelve true si contiene esa clase, en caso de contenerla no añade la clase especificada en el force y viceversa con el false.
    element.classList.contains("class"); | -> Devuelve true o false en función si tiene la clase o no.
    element.classList.replace("oldclase", "newclass"); | -> Sustituye la clase del primer parametro por la del segundo.
Atributos directos más importantes
    id
    value

    4. Eventos de ratón y teclado

Documentación: https://developer.mozilla.org/es/docs/Web/Events
Un evento es cualquer cosa que sucede en nuestro documento. Puede ejecutarlo un usuario o la misma programación de la página.
La sintaxis correcta para el mantenimiento y lectura de una página web sería: Element.addEventosListener('event', callback);
El callback es una función anonima que se ejecuta cuando se dispara el evento.

    5. Objeto evento

El objeto evento vive siempre y cuando haya un evento.
Ejemplo del objeto evento: input.addEventListener("keyup", (e) => console.log(e));
El objeto evento nos permite saber donde hicimos click. Por ejemplo si tenemos un div dentor de otro div, podemos saber donde se hizo click y a que objeto interno afecto. Ejemplo en el ejercicio 4 del curso-
Los eventos los podemos escuchar (addEventListener) y también los podemos forzar. Para forzarlos simplemente utilziamos la sintaxis element.evento(). 
Podemos evitar el comportamiento por default de los eventos utilizando .preventDefault(). Esto puede ser muy util para bloquear el envio de un formulario al hacer click en un boton de "Enviar".

    6. Crear e instanciar elementos

Crear un elemento: document.createElement(element)
Escribir texto en un elemento: element.textContent = texto
Escribir HTML en un elemento: element.innerHTML = código HTML

Añadir un elemento al DOM: parent.appendchild(element);

Añadir fragmentos de código: document.createDocumentFragment();

Ejemplos prácticos y buenas prácticas en el ejercicio correspondiente. 
Utilizar un bucle for e insertar HTML en el innerHTML hace que cada vuelta del bucle estamos inyectando codigo HTML en el DOM. El DOM tiene aspecto de arbol de nodos, cada vez que inyectamos de esta manera se esta redibujando ese arbol por completo, lo cual hace que sea ineficiente al gastar muchos recursos del navegador. Para evitar el inconveniente del for, se creo el document.createDocumentFragment(); no sobrecargamos el navegador al hacer este tipo de operaciones ya que simplemente agregamos un nodo en el arbol y no redibujamos el arbol entero por cada bucle del for.

    7. DOM - Recorrerlo (DOM Traversing)

El DOM traversing (atravesar el DOM) nos permite situarnos en un nodo y poder movernos entre los mismos.
En caso de no existir un padre, hijo, hermano o cercano devuelve null.
Se pueden combinar cada una de las propiedades y/o repetirlas.
Las propiedades sin la palabra element devuelven tanto los elementos como texto "basura" (en realidad es un salto de linea del documento HTML entre cada tag, lo que hace engorroso leer el elemento). Salvo casos especiales se recomienda usar los que contengan la palabra element.
Cada una de las propiedades debe estar precedida por el nodo al cual hacemos referencia. Ejemplo NODO.propiedad.
Verificar los ejemplos en la carpeta correspondiente para clarificar.

Padre - parent (Nodo del que desciende).
    parentNode: Devuelve el nodo padre (que puede no sr un elemento).
    parentElement:  Devuelve el nodo del elemento padre.

    NOTA: Los nodos tipo Document y DocumentFragment nunca van a tener un elemento padre, parentNode devolverá siempre null.

Hijos - child (Nodo que desciende de un padre)
    childNodes: Devuelve todos los nodos hijos.
    children: Devuelve todos los nodos elementos hijos.
    firstChild: Devuelve el primer nodo hijo.
    firstElementChild: Devuelve el primer nodo elemento hijo.
    lastChild: Devuelve el último nodo hijo.
    lastElementChild: Devuelve el último nodo elemento hijo.
    hasChildNodes(): Devuelve true si el nodo tiene hijos y false si no tiene.

Hermanos - sibilings (Nodo al mismo nivel)
    nextSibling: Devuelve el siguiente nodo hermano
    nextElementSibling: Devuelve el siguiente nodo elemento hermano.
    previousSibling: Devuelve el anterior nodo hermano
    previousElementSibling: Devuelve el anterior nodo elemento hermano.

Cercano
    closest(selector): Selecciona el nodo más cercano que cumpla con el selector, aún es experimental.

    8. Insertar, clonar y borrar elementos

Anteriormente vimos como colocar de manera correcta elementos HTML a través del DOM JS, sin embargo, solo vimos como locarlos al final del elemento al cual le hacemos un append. A continuación veremos como colocar un elemento en cualquier lugar de nuestro HTML, clonar y remover nodos del DOM.
Muchas veces vamos a necesitar acceder a un children del parent para poder colocarlo antes o despues dentro del parent, y que no salga salvo que lo querramos. 
Al clonar debemos tener cuidado de no repetir un ID.
Verificar los ejemplos en la carpeta correspondiente para clarificar.

Insertar y eliminar elementos 2
    parent.insertBefore(newElement, referenceElement): Insertar un elemento antes del elemento de referencia.

    SOPORTE TOTAL:
    parent.insertAdjacentElement(position, element):
    parent.insertAdjacentHTML(position, HTML):
    parent.insertAdjacentText(position, text):
    
    positions:
        beforebegin: Antes de que empiece (hermano anterior).
        afterbegin: Despues de que empiece (primer hijo).
        beforeend: Antes de que acabe (último hijo).
        afterend: Después de que acabe (hermano siguiente).
        
    parent.replaceChild(newChild, oldChild): Reemplaza un hijo por otro

DOM manipulation convenience methods - JQuery Like: https://caniuse.com/#search.jQuery-like

    positions:
        parent.before(Element): Antes de que empiece (hermano anterior).
        parent.prepend(Element): Despues de que empiece (primer hijo).
        parent.append(Element): Antes de que acabe (último hijo).
        parent.after(Element): Después de que acabe (hermano siguiente).
        
        child.replaceWith(newChild)

Clonar y eliminar elementos
    element.cloneNode(true|false): Clona el nodo. Si le pasamos true clona todo el elemento con los hijos, si le pasamos false clona solo el elemento sin los hijos.
    element.remove(): Elimina el nodo del DOM.
    element.removeChild(child): Elimina el nodo hijo del DOM.

    9. Objetos nativos y timers

Objeto window - Es el objeto global, de él descienden directa o indirectamente todos los objetos.
Algunos ejemplos directos
    No se recomienda utilizarlas ya que son ventanas que pausan la carga/ejecucion de la pagina hasta que se resuelvan. Salvo casos concretos no se recomienda utilizar.
    alert() -> Genera un pop-up de alerta con un boton de aceptar.
    prompt() -> Genera un pop-up con un textbox para ingresar datos con un boton de aceptar y otro de cancelar. 
    confirm() -> Genera un pop-up que devuelve true si acepta y false si cancela. No puede ser rediseñado con CSS.

Objeto console - Es el objeto que contiene la consola del navegador. Todos los navegadores tienen su propia consola.
https://developer.mozilla.org/es/docs/Web/API/Console
Algunos ejemplos
    console.log() -> Imprime información en consola.
    console.dir() -> A veces el navegador cambia la manera de mostrar la información y no nos deja desplegar las propiedades de, por ejemplo, un elementO.
    Para ello con el dir podemos obligar a que siempre aparezca de esa forma.
    console.error() -> Imprime mensajes de error.
    console.table() -> Imprime una tabla indice:valores.

Objeto location - Es el objeto que contiene la barra de direcciones.
https://developer.mozilla.org/es/docs/Web/API/Location
Algunos ejemplos
    location.href -> Nos devuelve la dirección URL. Tambien nos sirve para cambiar el valor de la URL, ejemplo: location.href = "https://google.com"
    location.protocol -> Nos devuelve el protocolo de la pagina (http, https, etc).
    location.host -> Nos devuelve el dominio principal que estamos visualizando. A pesar de estar en una carpeta o un subdirectorio, nos da la localización principal del dominio siempre.
    location.pathname -> Lo contrario a host. Nos da la localización de donde estemos en el dominio.
    location.hash -> Es una forma de pasar parametros entre pagina, podemos utilizarlo para tener un solo HTML y en función del hash que pasemos cargar una información u otra.
    location.reload() -> Recarga la pagina.

Objeto history - Es el objeto que trabaja con el historial de la pestaña donde navegamos.
https://developer.mozilla.org/es/docs/DOM/Manipulado_el_historial_del_navegador
    back() -> Va hacia la pagina web anterior de la pestaña (Si existe).
    foward() -> Va hacia la pagina web posterior de la pestaña pestaña (Si existe).
    go(n|-n)  -> Positivo va a X cantidad posterior, negativo va -X cantidad anterior (Si existe).
    length -> Nos da la cantidad de paginas web que se abrieron en la pestaña.

Objeto date - Es el objeto permite trabajar con fechas y horas.
https://developer.mozilla.org/es/docs/JavaScript/Referencia/Objetos_globales/Date
https://www.w3schools.com/jsref/jsref_obj_date.asp

Timers - Los timers nos permiten establecer que una función se ejecuta despues de X tiempo y automaticamente al leerla.
    Timeout:
    https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout
    setTimeout(() => {code}, delay in miliseconds) - Hace que se ejecuta la función después del delay. Si lo referenciamos mediante una variable/constante podemos pararlo con clearTimeout(referencia).

    Interval:
    https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval
    setInterval(() => {code}, delay in miliseconds) - Hace que se ejecute una función cada delay milisegundo. Si lo referenciamos mediante una variable/constante podemos pararlo con clearInterval(referencia).



        4. Peticiones HTTP 

    AJAX

AJAX, acrónimo de Asynchronous JavaScript And XML, es una técnica de desarrollo web para crear aplicaciones web asíncronas. Estas aplicaciones se ejecutan en el cliente, es decir, en el navegador de los usuarios mientras se mantiene la comunicación asíncrona con el servidor en segundo plano.

                FOTO ASYNC VS SYNC

    Pequeña definición de AJAX
¿Cómo funciona la Web? Nosotros hacemos una petición a través del protocolo HTTP a un dominio, solicitando a un servidor o una nube esa cierta información. Ese servidor nos devuelve esa información como página web, que esta compuesta por HTML, CSS, JS, imagenes, video, etc. Así es como funcionan todas las webs que no utilizan AJAX.
Cuando nosotros utilizamos AJAX lo que estamos haciendo es interceptar esa respuesta para evitar que la pagina se recarge. De esta forma lo que hacemos es, en lugar de solicitar todos los datos, hacemos la petición a través del protocolo HTTP pero solo solicitamos ciertos datos, y esos datos cuando llegan lo que hacemos es guardarlos en un objeto. Entonces de esta forma obtenemos los datos del servidor pero no recargamos la pagina porque no estamos cargando esos datos en el navegador, los tenemos en un objeto y una vez que esta ahi trabajamos con ese objeto de la forma que necesitemos.
Otra definicion: https://es.wikipedia.org/wiki/AJAX

Las peticiones a una API se ven normalmente como objetos construidos en formato JSON.

    API

https://www.redhat.com/es/topics/api/what-are-application-programming-interfaces
Una API o interfaz de programación de aplicaciones es un conjunto de definiciones y protocolos que se usa para diseñar e integrar el software de las aplicaciones.
Las API permiten que sus productos y servicios se comuniquen con otros, sin necesidad de saber cómo están implementados. Esto simplifica el desarrollo de las aplicaciones y permite ahorrar tiempo y dinero. Las API le otorgan flexibilidad; simplifican el diseño, la administración y el uso de las aplicaciones; y ofrecen oportunidades de innovación, lo cual es ideal al momento de diseñar herramientas y productos nuevos (o de gestionar los actuales).
Otra definicion: https://es.wikipedia.org/wiki/Web_API#:~:text=Una%20API%20es%20una%20interfaz,funciones%20de%20un%20determinado%20software.


En este curso no veremos AJAX con JQuery al ser una libreria pesada y obsoleta. Veremos como hacer peticiones sin JQuery y que sean compatibles con navegadores antiguos.

Normalmente las peticiones a los servidores se hacen a través de PHP, es la forma más común. Hoy por hoy node esta comiendo parte del mercado, sin embargo PHP sigue siendo la principal.
Vamos a utilizar la API https://jsonplaceholder.typicode.com para realizar peticiones AJAX, ademas de montar un pequeño servidor PHP (WampServer). 


    1. Objeto XMLHTTPRequest

Para guardar/lanzar una peticion por convencion utilizamos el nombre xhr para guardar el objeto XMLHttpRequest.
Para saber si un navegador soporte un objeto XMLHttpRequest simplemente preguntamos en un if si exisite el objeto en la clase window. Si existe asignamos la variable xhr a un new de XMLHttpRequest(), de lo contrario utilizamos el objeto ActiveXObject("Microsoft.XMLHTTP");
De esta manera nos ahorramos todo jQuery.

La variable en la cual guardamos el objeto XMLHttpRequest/ActiveXObject("Microsoft.XMLHTTP"); tiene un metodo llamado open(). Este metodo recibe en su primer parametro el metodo que vamos a utilizar para hacer la peticion (puede ser GET, POST, PUT, DELETE), y en su segundo parametro el link interno u externo al cual queremos hacer la conexion para la peticion.
Aclaracion: Si se hace a través de GET los codigos/parametros (por ejemplo los que aparecen en un metodo GET de formularios o el ejemplo) a acceder hay que ponerlos en la URL a al que hacemos la peticion. En cambio por POST tendriamos que crear un objeto donde vamos a guardar esa información.
Podemos hacer peticiones para enviar datos a un lugar o recibir datos de ese lugar. Por ejemplo un GET a un JSON como esta ahi debajo, enviar datos en JSON a una pagina o cargar datos a una DB.

Ejemplo del metodo POST en la carpeta "1.3 Objeto XMLHTTPRequest 3"

Ejemplo accediendo a una ruta externa:
    xhr.open("GET", "https://jsonplaceholder.typicode.com/users");

Con el metodo send() enviamos esta petición.
Ejemplo:
    xhr.send();

Sin embargo, antes de enviar esta peticion debemos decirle que hacer con esos datos antes de enviarlos. Por lo tanto antes del send debemos codear que vamos a hacer con la información recibida. También debemos verificar que el hilo asincrono haya recibido toda la información antes de enviarla/procesarla, para ello utilizamos el evento load. Este evento se dispara cuando toda la información a llegado al objeto.
Ejemplo parseando del JSON recibido solamente el ID y nombre: 
        xhr.addEventListener("load", (data) => {
        const dataJSON = JSON.parse(data.target.response);
        const list = document.getElementById("list");
        for(let userInfo of dataJSON){
            const listItem = document.createElement("li");
            listItem.textContent = `${userInfo.id} - ${userInfo.name}`
            list.appendChild(listItem);
        }
    }); 



    2. Callbacks

Un callback es una función que se ejecuta a través de una función. Los callbacks se volvieron obsoletos ya que son dificiles de mantener y se empezaron a utilizar las promesas. Los callbacks no son asincronos.

    3. Promesas

Documentación: https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Using_promises
Una promesa es un objeto que dentro tiene dos callbacks. Es un objeto que representa la terminación o el fracaso de una operación asíncrona.

 Otra definicion
En promesas utilizamos funciones de tipo callback.
Una promesa básicamente es código que tiene varios estados, así que vamos a poder lanzar una petición 
para procesar un código. En dado caso que la promesa se resuelta correctamente se resuelve el codigo y en 
caso que haya tenido problemas se manda a llamar el error.
Por lo tanto podemos decir que existen dos caminos: Un en el que se ejecuto el codigo correctamente y se 
resolvio el mismo y otro en el cual falla el codigo y se manda a llamar el error en el catch.
Mientras la promesa no haya terminado de ejecutar el codigo se encuentra en estado de pendiente. Una 
vez ejecutado el codigo si se puede resolver utilizamos la funcion .then(), en caso de que no se haya podido 
procesar utilizaremos la funcion .catch().
Una Promise (promesa en castellano) es un objeto que representa la terminación o el fracaso de una 
operación asíncrona. Dado que la mayoría de las personas consumen promises ya creadas, esta guía 
explicará primero cómo consumirlas, y luego cómo crearlas.
La palabra async nos va a permitir el uso de promesas. Al poner la palabra antes de la definición de un 
método significa que esta obligado a regresar una promesa.
La palabra reservada await solo puede utilizarse dentro de una función aysnc.



Una promesa se crea con el constructor de la clase Promise(FUNCION); Dentro de los parentesis recibe como argumentos un puntero a función o una función anonima. Ambas funciones deben tener un parametro de resuelto y otro de rechazado, ambos parametros son callbacks.
Ejemplo: const promise = new Promise((resolve,reject) => {});
Una vez resuelta la función se devuelve el objeto creado como Promesa(). Nos devuelve el estado fulfilled si pudo terminar su ejecución.
Para leer el contenido de las promesas tenemos los metodos .then() si todo fue bien y .catch() si ocurrio algún error. Ambas funciones reciben punteros a funcion o funciones anonimas.
Los catch funcionan para todos los then() que utilicemos. Los then() no hacen falta ser anidados.


    4. Fetch - Introducción

Es el reemplazo moderno del objeto XMLHTTPRequest.
Fetch API
Proporciona una interfaz JavaScript para acceder y manipular partes del canal HTTP, como peticiones y respuestas. Básicamente y muy por encima lo que hace es encapsular y crear una promesa con sus callbacks.
También provee de un método global fetch() que proporciona una forma fácil y lógica de obtener recursos de forma asíncronica por la red.
Esta basado en Promesas, por lo cual tiene un response y un reject internos.
    Response tiene varios métodos: 
    arrayBuffer(): Archivos binarios en bruto (mp3, pdf, jpg, etc). Se utiliza cuando se necesita manipular el contenido del archivo.
    blob(): Archivos binarios en bruto (mp3, pdf, jpg, etc). Se utiliza cuando no se necesita manipular el contenido y se va a trabajar con el archivo directamente.
    clone(): Crea un clon de un objeto de respuesta, idéntico en todos los sentidos, pero almacenado en una variable diferente.
    formData: Se utiliza para leer los objetos FormData.
    json(): Convierte los archivos json en un objeto de JavaScript.
    text(): Se utiliza cuando queremos leer un archivo de texto. Siempre se codifica en UTF-8.


        8.    Shortcuts

Pagina: https://medium.com/@ashley.karhoff1/emmet-shortcuts-to-quickly-generate-html-tags-and-css-classes-aeb04cd48aec
Shortcut para crear varios elementos HTML duplicados: element{EJEMPLO-$}*CANTIDAD -> Las {} son opcionales, el $ da comienzo a partir del 1. Es posible combinarlo al final con el "." o el "#".
Para anidar elementos utilizamos el simbolo ">": Ejemplo: nav>ul>li*4>a
Añadir un div (por defecto) con una clase: ."nombreClase" -> Poniendo puntos añado mas clases
Añadir un div (por defecto) con un id y una clase (opcional): #"nombreId"."nombreClase" -> Poniendo puntos añado mas clases

